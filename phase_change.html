<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Water Phase Change Simulation</title>
<style>
  body {
    font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0;
    padding: 20px;
    background-color: #f0f0f0;
    color: #333;
  }
  h1 { color: #2c3e50; }
  .container {
    display: flex;
    gap: 20px;
    width: 100%;
    max-width: 1000px;
    align-items: flex-start;
  }
  #viewCanvas, #graphCanvas {
    border: 1px solid #2c3e50;
    background-color: #fff;
  }
  #viewCanvas { flex-grow: 1; }
  .side { display:flex; flex-direction:column; gap:20px; }
  #graphCanvas { width:300px; height:200px; }
  .controls {
    display: flex;
    flex-direction: column;
    gap: 12px;
    padding: 20px;
    background-color: #ecf0f1;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    width: 260px;
  }
  .controls label { font-weight: bold; color: #34495e; }
  .row { display: flex; align-items: center; gap: 10px; }
  .timescale button, .row button {
    padding: 6px 12px;
    background-color: #3498db;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
  }
  .timescale button.selected { background-color: #2ecc71; }
  .timescale button:not(.selected):hover, .row button:hover { background-color: #2980b9; }
  .energy-bar { width: 100%; height: 20px; background-color: #ddd; border-radius: 10px; overflow: hidden; }
  .energy-fill { height: 100%; background-color: #e67e22; width: 0%; }
</style>
</head>
<body>
<h1>Water Phase Change</h1>
<div class="container">
  <canvas id="viewCanvas" width="500" height="400"></canvas>
  <div class="side">
    <div class="controls">
      <div class="row">
        <label>Heat Power</label>
        <input type="range" id="powerSlider" min="0" max="100" value="50">
        <span id="powerDisplay">50%</span>
      </div>
      <div class="row timescale">
        <label>Time</label>
      <button data-scale="1" class="selected">×1</button>
      <button data-scale="2">×2</button>
      <button data-scale="3">×3</button>
      </div>
      <div class="row">
        <button id="playButton">Play</button>
        <button id="resetButton">Reset</button>
      </div>
      <div class="row">
        <span id="tempDisplay">0.0 °C</span>
      </div>
      <div class="energy-bar"><div id="energyFill" class="energy-fill"></div></div>
      <div class="row"><span id="energyText">0 kJ</span></div>
    </div>
    <canvas id="graphCanvas" width="300" height="200"></canvas>
  </div>
</div>
<script>
const MASS = 100; // g
const CP_ICE = 2.09;
const CP_WATER = 4.18;
const CP_STEAM = 2.01;
const L_F = 334;
const L_V = 2260;
const MAX_POWER = 5000; // J/s
const Q_MELT = MASS * L_F;
const Q_HEAT_WATER = MASS * CP_WATER * 100;
const Q_VAP = MASS * L_V;
const Q_TOTAL = Q_MELT + Q_HEAT_WATER + Q_VAP;

const BEAKER = {x:80,y:330,w:180,h:230};
const ICE_INIT_WIDTH = 80;
const ICE_INIT_HEIGHT = 150;
const FULL_WATER_HEIGHT = 110;

let energy = 0;
let time = 0;
let isPaused = true;
let timeScale = 1;
let temp = 0;
let state = 'ice';
let data = [];
let steamParticles = [];

const viewCanvas = document.getElementById('viewCanvas');
const vctx = viewCanvas.getContext('2d');
const gCanvas = document.getElementById('graphCanvas');
const gctx = gCanvas.getContext('2d');

const powerSlider = document.getElementById('powerSlider');
const powerDisplay = document.getElementById('powerDisplay');
const playButton = document.getElementById('playButton');
const resetButton = document.getElementById('resetButton');
const tempDisplay = document.getElementById('tempDisplay');
const energyFill = document.getElementById('energyFill');
const energyText = document.getElementById('energyText');

document.querySelectorAll('.timescale button').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    document.querySelectorAll('.timescale button').forEach(b=>b.classList.remove('selected'));
    btn.classList.add('selected');
    timeScale = +btn.dataset.scale;
  });
});

powerSlider.addEventListener('input', ()=>{
  powerDisplay.textContent = powerSlider.value + '%';
});

playButton.addEventListener('click', ()=>{
  isPaused = !isPaused;
  playButton.textContent = isPaused ? 'Play' : 'Pause';
});

resetButton.addEventListener('click', reset);

function reset(){
  energy = 0;
  time = 0;
  temp = 0;
  state = 'ice';
  data = [];
  steamParticles = [];
  energyFill.style.width = '0%';
  energyText.textContent = '0 kJ';
  tempDisplay.textContent = '0.0 °C';
}

function updateState(){
  if (energy === 0) {
    state = 'ice';
    temp = 0;
  } else if (energy < Q_MELT) {
    state = 'melting';
    temp = 0;
  } else if (energy < Q_MELT + Q_HEAT_WATER) {
    state = 'liquid';
    temp = (energy - Q_MELT) / (MASS * CP_WATER);
  } else if (energy < Q_MELT + Q_HEAT_WATER + Q_VAP) {
    state = 'boiling';
    temp = 100;
  } else {
    state = 'steam';
    temp = 100 + (energy - Q_MELT - Q_HEAT_WATER - Q_VAP) / (MASS * CP_STEAM);
  }
}

function drawMain(){
  vctx.clearRect(0,0,viewCanvas.width,viewCanvas.height);
  const beaker = BEAKER;

  // burner flame depends on temperature and power
  const power=powerSlider.value;
  if(power>0){
    const fh = 20 + temp*0.4;
    vctx.fillStyle='orange';
    vctx.beginPath();
    vctx.moveTo(beaker.x+beaker.w/2, beaker.y+20);
    vctx.quadraticCurveTo(beaker.x+beaker.w/2-20, beaker.y+20-fh/2, beaker.x+beaker.w/2, beaker.y+20-fh);
    vctx.quadraticCurveTo(beaker.x+beaker.w/2+20, beaker.y+20-fh/2, beaker.x+beaker.w/2, beaker.y+20);
    vctx.fill();
  }

  // beaker
  vctx.strokeStyle='#333';
  vctx.lineWidth=2;
  vctx.strokeRect(beaker.x, beaker.y - beaker.h, beaker.w, beaker.h);

  // compute masses
  let massLiquid=0, meltFrac=0;
  if(energy<Q_MELT){
    meltFrac = 1 - energy/Q_MELT;
    massLiquid = MASS - MASS*meltFrac;
  }else if(energy < Q_MELT + Q_HEAT_WATER){
    massLiquid = MASS;
  }else if(energy < Q_MELT + Q_HEAT_WATER + Q_VAP){
    massLiquid = Math.max(0, MASS - (energy - Q_MELT - Q_HEAT_WATER)/L_V);
  }else{
    massLiquid = 0;
  }

  const waterHeight = FULL_WATER_HEIGHT * (massLiquid/MASS);
  const waterTop = beaker.y - waterHeight;

  // draw water
  if(massLiquid>0){
    vctx.fillStyle='#a8d0ff';
    vctx.fillRect(beaker.x, waterTop, beaker.w, waterHeight);
  }

  // draw ice block
  if(meltFrac>0){
    const iw = ICE_INIT_WIDTH*meltFrac;
    const ih = ICE_INIT_HEIGHT*meltFrac;
    const ix = beaker.x + (beaker.w - iw)/2;
    const iy = beaker.y - ih;
    vctx.fillStyle='#ccc';
    vctx.fillRect(ix, iy, iw, ih);
    vctx.fillStyle='#888';
    for(let i=0;i<Math.floor(ih/20);i++){
      for(let j=0;j<Math.floor(iw/20);j++){
        vctx.fillRect(ix+5+j*20, iy+5+i*20, 2, 2);
      }
    }
  }

  // evaporation bubbles
  if(state==='liquid' && temp>80){
    const bub = Math.floor((temp-80)/20*5);
    vctx.fillStyle='rgba(255,255,255,0.7)';
    for(let i=0;i<bub;i++){
      const bx = beaker.x+20+Math.random()*(beaker.w-40);
      const by = waterTop+Math.random()*waterHeight;
      vctx.beginPath();
      vctx.arc(bx,by,4,0,Math.PI*2);
      vctx.fill();
    }
  }

  if(state==='boiling'){
    vctx.fillStyle='rgba(255,255,255,0.8)';
    for(let i=0;i<10;i++){
      const bx = beaker.x+20+Math.random()*(beaker.w-40);
      const by = waterTop+Math.random()*waterHeight;
      vctx.beginPath();
      vctx.arc(bx,by,5,0,Math.PI*2);
      vctx.fill();
    }
    // spawn steam particles escaping
    if(Math.random()<0.3){
      steamParticles.push({x:beaker.x+beaker.w/2,y:waterTop,vx:(Math.random()-0.5)*30,vy:-40-Math.random()*30});
    }
  }

  // draw steam particles and update
  steamParticles.forEach(p=>{
    p.x+=p.vx*0.016; p.y+=p.vy*0.016;
  });
  steamParticles=steamParticles.filter(p=>p.y>beaker.y-beaker.h-50 && p.x>beaker.x && p.x<beaker.x+beaker.w);
  vctx.fillStyle='rgba(200,200,200,0.6)';
  steamParticles.forEach(p=>{vctx.beginPath();vctx.arc(p.x,p.y,5,0,Math.PI*2);vctx.fill();});

  // thermometer
  const tColor = `hsl(${240 - Math.min(temp,120)*2},70%,50%)`;
  vctx.fillStyle=tColor;
  vctx.fillRect(beaker.x+beaker.w+40, beaker.y - 150, 30, 150);
  vctx.strokeRect(beaker.x+beaker.w+40, beaker.y - 150, 30, 150);
  vctx.fillStyle='#333';
  vctx.fillText(temp.toFixed(1)+' °C', beaker.x+beaker.w+35, beaker.y - 160);
}

function drawGraph(){
  gctx.clearRect(0,0,gCanvas.width,gCanvas.height);
  const margin=30;
  const w=gCanvas.width;
  const h=gCanvas.height;
  const maxT=120;
  const maxTime=Math.max(10,time);
  gctx.strokeStyle='#000';
  gctx.beginPath();
  gctx.moveTo(margin,margin);
  gctx.lineTo(margin,h-margin);
  gctx.lineTo(w-margin,h-margin);
  gctx.stroke();
  gctx.fillText('Time (s)', w/2, h-10);
  gctx.save();
  gctx.translate(15,h/2);
  gctx.rotate(-Math.PI/2);
  gctx.fillText('Temperature (°C)',0,0);
  gctx.restore();
  gctx.strokeStyle='#888';
  [0,100].forEach(t=>{
    const y=h-margin - t/maxT*(h-2*margin);
    gctx.beginPath();
    gctx.moveTo(margin,y);
    gctx.lineTo(w-margin,y);
    gctx.stroke();
  });
  gctx.strokeStyle='#e74c3c';
  gctx.beginPath();
  data.forEach((pt,i)=>{
    const x=margin+pt.t/maxTime*(w-2*margin);
    const y=h-margin-pt.T/maxT*(h-2*margin);
    if(i===0) gctx.moveTo(x,y); else gctx.lineTo(x,y);
  });
  gctx.stroke();
}

function update(dt){
  if(!isPaused){
    const power=powerSlider.value/100*MAX_POWER;
    energy += power*dt*timeScale;
    time += dt*timeScale;
    updateState();
    data.push({t:time, T:temp});
    if(data.length>500) data.shift();
    const perc=Math.min(100, energy/Q_TOTAL*100);
    energyFill.style.width=perc+'%';
    energyText.textContent=(energy/1000).toFixed(1)+' kJ';
    tempDisplay.textContent=temp.toFixed(1)+' °C';
  }
}

let last=0;
function animate(timestamp){
  if(!last) last=timestamp;
  const dt=(timestamp-last)/1000;
  last=timestamp;
  update(dt);
  drawMain();
  drawGraph();
  requestAnimationFrame(animate);
}
reset();
requestAnimationFrame(animate);
</script>
</body>
</html>
